<?xml version="1.0" encoding="UTF-8"?>
<?usoft-xml version="1.0" action="multi-tables-import"?><MultiImport>
<Columns documentName="Columns">
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="CULTURE_NAME" DOMAIN_NAME="OTS_CALENDAR_STRING" PROMPT="Culture" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="3" LOFSEQNO="" PERC_FULL="50" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="DAY_IN_MONTH" DOMAIN_NAME="OTS_CALENDAR_INT_4" PROMPT="Day in month" KEYORDER="1" MANDATORY="Y" INPUT_ALLOWED="Y" UPDATABLE="N" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="6" LOFSEQNO="" PERC_FULL="" PERC_NULL="0" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="DAY_NAME" DOMAIN_NAME="OTS_CALENDAR_STRING" PROMPT="Day name" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="11" LOFSEQNO="" PERC_FULL="50" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="DAY_OF_WEEK" DOMAIN_NAME="OTS_CALENDAR_INT_1" PROMPT="Day of week" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="8" LOFSEQNO="" PERC_FULL="" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="DAY_OF_YEAR" DOMAIN_NAME="OTS_CALENDAR_INT_4" PROMPT="Day of year" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="9" LOFSEQNO="" PERC_FULL="" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="MONTH_NAME" DOMAIN_NAME="OTS_CALENDAR_STRING" PROMPT="Month name" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="10" LOFSEQNO="" PERC_FULL="50" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="MONTH_NO" DOMAIN_NAME="OTS_CALENDAR_INT_2" PROMPT="Month number" KEYORDER="1" MANDATORY="Y" INPUT_ALLOWED="Y" UPDATABLE="N" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="5" LOFSEQNO="" PERC_FULL="" PERC_NULL="0" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="PERIOD_END" DOMAIN_NAME="OTS_CALENDAR_STRING" PROMPT="End of period" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="2" LOFSEQNO="" PERC_FULL="50" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="PERIOD_START" DOMAIN_NAME="OTS_CALENDAR_STRING" PROMPT="Start of period" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="1" LOFSEQNO="" PERC_FULL="50" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="WEEK_NO" DOMAIN_NAME="OTS_CALENDAR_INT_2" PROMPT="Week number" KEYORDER="N" MANDATORY="N" INPUT_ALLOWED="Y" UPDATABLE="Y" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="7" LOFSEQNO="" PERC_FULL="" PERC_NULL="50" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
<T_COLUMN TABLE_NAME="OTS_CALENDAR_DAY" COLUMN_NAME="YEAR" DOMAIN_NAME="OTS_CALENDAR_INT_4" PROMPT="Year" KEYORDER="1" MANDATORY="Y" INPUT_ALLOWED="Y" UPDATABLE="N" QUERY_ALLOWED="Y" COLUMN_TYPE="D" DISPLAYED="Y" DEF_VALUE="" SEQNO="4" LOFSEQNO="" PERC_FULL="50" PERC_NULL="0" HELP_TEXT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" UNDER_VC="Y"/>
</Columns>
<Component_Constructors documentName="Component Constructors">
<T_RDMI_COMPONENT_CONSTRUCTOR COMPONENT_NAME="OTS_CALENDAR_DAY" DESCRIPTION="This Calendar component is intended to be used in a Calendar table component.&#13;&#10;OTS_CALENDARDAY steps through the days in a certain period.&#13;&#10;The default period is specified in the constructor SQL, together with a default culture and default month and day name format.&#13;&#10;&#13;&#10;This component has to be considered as an example showing various programming techniques. For production purposes, the example can be extended or reduces to the actual requirements.&#13;&#10;This example shows:&#13;&#10;&#9;-using C# calendar arithmetic&#13;&#10;&#9;-a C# component using a query protocol to support a table component. i.e. usage of a table in USoft that can be queried to show calendar data&#13;&#10;&#9;-an example of using query conditions; they are passed as parameters in an xml format to the QueryExe method when &quot;Extended query conditions&quot; are used.&#13;&#10;&#9;-the use of  a regular expression&#13;&#10;&#9;-parsing an Enum from a string&#13;&#10;&#9;&#9;&#13;&#10;&#13;&#10;The component table OTS_CALENDARDAY can be queried to find all days in a certain period.&#13;&#10;In the USoft application, open the OTS_CALENDARDAY table and query all records to see the result.&#13;&#10;The default period is set in the constructor SQL. This period  can be overridden by specifying values for  the period start and end in the query (i.e. specify value(s) for PERIOD_START and/or PERIOD_END).&#13;&#10;Note that specifying PERIOD_START and PERIOD_END is a way of parameterizing the component and deviates from normal table behaviour.&#13;&#10;Operators &lt;, &lt;=, &gt;, &gt;=, % (LIKE) are not supported therefore on these fields.&#13;&#10;(For deployment purposes one could remove such fields from the component and only specify the period in the constructor SQL)&#13;&#10;The start and end period also support a basic date expression. Besides plain dates (as e.g. 2019 or 1-5-2020) one can specify expressions like: now&#13;&#10;&#13;&#10;&#13;&#10;The default culture (set by the constructor SQL) can be overridden by passing a culture name as e.g. en_US.&#13;&#10;The culture determines the language used to show month and day names&#13;&#10;This too this is a way of parameterizing the component with the same note above about operators applies.&#13;&#10;&#13;&#10;The year can be set (and must of course fall in the period to find any days at all). &#13;&#10;The year can be used with conditions &lt;, &lt;=, &gt;, &gt;= and the component will use these conditions to reduce the number of days fetched for efficiency.&#13;&#10;Query conditions on the other fields (month number, day in month, day of week, day of year, month name, day name) are resolved by the rules engine.&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following helper methods:&#13;&#10;select OTS_CALENDARDAY.ListFormats()&#9;&#9;=&gt; lists all DateTime input formats that can be used to specify the period (in the constructor SQL and/or as query condition)&#13;&#10;select OTS_CALENDARDAY.ListCultures()&#9;&#9;=&gt; lists all the culture names (with their display name)&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following utility methods:&#13;&#10;select OTS_CALENDARDAY.AddDays( datestring, howmanydays, format)&#9;&#13;&#10;&#9;=&gt; reads the datestring (according to the input formats). An empty input string is taken as the current datetime.&#13;&#10;&#9;=&gt; adds a number of days, e.g. 5  (which can also be a fraction, e.g. 1.5) &#13;&#10;&#9;=&gt; produces a date string as output in the specified format. An empty format string is taken as the USoft default format ( yyyy/MMddHHmmss )&#13;&#10;&#13;&#10;select OTS_CALENDARDAY.DaysBetween(datestring1, datestring2)&#13;&#10;&#9;=&gt;reads both datestrings &#13;&#10;&#9;=&gt;produces the number of days (can be a fraction) between the two dates&#13;&#10;&#13;&#10;Simple date expressions are supported for the start and end of period. (You could extend/change the basic grammar or use professional parsing techniques for more, or entirely leave out this example behaviour).&#13;&#10;Expression examples (the expressions are case insensitive. For details check the  implementation of the ParseDateExpr method):&#13;&#10;now&#13;&#10;yesterday&#13;&#10;tomorrow&#13;&#10;this  Monday&#13;&#10;next Monday&#13;&#10;following Monday&#13;&#10;next year&#13;&#10;last year&#13;&#10;yesterday + 2 weeks&#13;&#10;previous Monday + 1 week&#13;&#10;this day plus 1 year&#13;&#10;&#13;&#10;Note that only English day names and the English names year, month and day are supported.&#13;&#10;Note that the interpretation of &quot;this year&quot; would be January first for the start period but December 31 for the end period.&#13;&#10;In other words, to get all days in a year you can use in both period fields (start of period and end of period) the search condition: this year &#13;&#10;This month likewise refers to the begin or the end of the month and this week refers to begin or end of this week. &#13;&#10;Note that the following week can be addressed as:&#13;&#10;next week&#13;&#10;or&#13;&#10;this week + 1 week&#13;&#10;Also note that:&#13;&#10;yesterday + 1 &#13;&#10;adds one day (i.e. the default amount unit is days)&#13;&#10;yesterday + 1 week&#13;&#10;adds one week to yesterday&#13;&#10;this day&#13;&#10;is equivalent to&#13;&#10;now&#13;&#10;&#13;&#10;Finally,  note that fractions are not supported for year and month units. That is:&#13;&#10;now plus 1.5 year&#13;&#10;is not valid whereas&#13;&#10;now + 2.5 days &#13;&#10;is valid&#13;&#10;&#13;&#10;An example of a query would be:&#13;&#10;select YEAR, MONTHNAME, DAYOFWEEK, DAYNAME from OTS_CALENDARDAY where PERIOD_START='now' and PERIOD_END='this week' and CULTURE_NAME='nl-NL'" T_RDMI_AUTOMATION_SERVER="N" T_RDMI_JAVA_COMPONENT="N" T_RDMI_STATEFUL_COMPONENT="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" T_RDMI_WEB_SERVICE_COMPONENT="N" T_RDMI_DOTNET_COMPONENT="Y" T_RDMI_COMPONENT_CONSTRUCTOR="Y" CONSTRUCTOR_SQL="select null /*'nl-NL'*/, 'MMMM', 'dddd', '1-1-2000', '31-12-2050', 1&#13;&#10;/*&#13;&#10;&#9;The first argument: the default culture for day and month names. A null value defaults to the CurrentCulture. Call OTS_CALENDARDAY.ListCultures() for a list.&#13;&#10;&#9;The second argument: format for month names&#13;&#10;&#9;The third argument: format for daynames&#13;&#10;&#9;The fourth argument: default start of period&#13;&#10;&#9;The fifth argument: default end of period&#13;&#10;&#9;The sixt argument: number of days to step through the period&#13;&#10;*/" ACTIVE="Y"/>
</Component_Constructors>
<Components documentName="Components">
<T_RDMI_COMPONENT COMPONENT_NAME="OTS_CALENDAR_DAY" DESCRIPTION="This Calendar component is intended to be used in a Calendar table component.&#13;&#10;OTS_CALENDARDAY steps through the days in a certain period.&#13;&#10;The default period is specified in the constructor SQL, together with a default culture and default month and day name format.&#13;&#10;&#13;&#10;This component has to be considered as an example showing various programming techniques. For production purposes, the example can be extended or reduces to the actual requirements.&#13;&#10;This example shows:&#13;&#10;&#9;-using C# calendar arithmetic&#13;&#10;&#9;-a C# component using a query protocol to support a table component. i.e. usage of a table in USoft that can be queried to show calendar data&#13;&#10;&#9;-an example of using query conditions; they are passed as parameters in an xml format to the QueryExe method when &quot;Extended query conditions&quot; are used.&#13;&#10;&#9;-the use of  a regular expression&#13;&#10;&#9;-parsing an Enum from a string&#13;&#10;&#9;&#9;&#13;&#10;&#13;&#10;The component table OTS_CALENDARDAY can be queried to find all days in a certain period.&#13;&#10;In the USoft application, open the OTS_CALENDARDAY table and query all records to see the result.&#13;&#10;The default period is set in the constructor SQL. This period  can be overridden by specifying values for  the period start and end in the query (i.e. specify value(s) for PERIOD_START and/or PERIOD_END).&#13;&#10;Note that specifying PERIOD_START and PERIOD_END is a way of parameterizing the component and deviates from normal table behaviour.&#13;&#10;Operators &lt;, &lt;=, &gt;, &gt;=, % (LIKE) are not supported therefore on these fields.&#13;&#10;(For deployment purposes one could remove such fields from the component and only specify the period in the constructor SQL)&#13;&#10;The start and end period also support a basic date expression. Besides plain dates (as e.g. 2019 or 1-5-2020) one can specify expressions like: now&#13;&#10;&#13;&#10;&#13;&#10;The default culture (set by the constructor SQL) can be overridden by passing a culture name as e.g. en_US.&#13;&#10;The culture determines the language used to show month and day names&#13;&#10;This too this is a way of parameterizing the component with the same note above about operators applies.&#13;&#10;&#13;&#10;The year can be set (and must of course fall in the period to find any days at all). &#13;&#10;The year can be used with conditions &lt;, &lt;=, &gt;, &gt;= and the component will use these conditions to reduce the number of days fetched for efficiency.&#13;&#10;Query conditions on the other fields (month number, day in month, day of week, day of year, month name, day name) are resolved by the rules engine.&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following helper methods:&#13;&#10;select OTS_CALENDARDAY.ListFormats()&#9;&#9;=&gt; lists all DateTime input formats that can be used to specify the period (in the constructor SQL and/or as query condition)&#13;&#10;select OTS_CALENDARDAY.ListCultures()&#9;&#9;=&gt; lists all the culture names (with their display name)&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following utility methods:&#13;&#10;select OTS_CALENDARDAY.AddDays( datestring, howmanydays, format)&#9;&#13;&#10;&#9;=&gt; reads the datestring (according to the input formats). An empty input string is taken as the current datetime.&#13;&#10;&#9;=&gt; adds a number of days, e.g. 5  (which can also be a fraction, e.g. 1.5) &#13;&#10;&#9;=&gt; produces a date string as output in the specified format. An empty format string is taken as the USoft default format ( yyyy/MMddHHmmss )&#13;&#10;&#13;&#10;select OTS_CALENDARDAY.DaysBetween(datestring1, datestring2)&#13;&#10;&#9;=&gt;reads both datestrings &#13;&#10;&#9;=&gt;produces the number of days (can be a fraction) between the two dates&#13;&#10;&#13;&#10;Simple date expressions are supported for the start and end of period. (You could extend/change the basic grammar or use professional parsing techniques for more, or entirely leave out this example behaviour).&#13;&#10;Expression examples (the expressions are case insensitive. For details check the  implementation of the ParseDateExpr method):&#13;&#10;now&#13;&#10;yesterday&#13;&#10;tomorrow&#13;&#10;this  Monday&#13;&#10;next Monday&#13;&#10;following Monday&#13;&#10;next year&#13;&#10;last year&#13;&#10;yesterday + 2 weeks&#13;&#10;previous Monday + 1 week&#13;&#10;this day plus 1 year&#13;&#10;&#13;&#10;Note that only English day names and the English names year, month and day are supported.&#13;&#10;Note that the interpretation of &quot;this year&quot; would be January first for the start period but December 31 for the end period.&#13;&#10;In other words, to get all days in a year you can use in both period fields (start of period and end of period) the search condition: this year &#13;&#10;This month likewise refers to the begin or the end of the month and this week refers to begin or end of this week. &#13;&#10;Note that the following week can be addressed as:&#13;&#10;next week&#13;&#10;or&#13;&#10;this week + 1 week&#13;&#10;Also note that:&#13;&#10;yesterday + 1 &#13;&#10;adds one day (i.e. the default amount unit is days)&#13;&#10;yesterday + 1 week&#13;&#10;adds one week to yesterday&#13;&#10;this day&#13;&#10;is equivalent to&#13;&#10;now&#13;&#10;&#13;&#10;Finally,  note that fractions are not supported for year and month units. That is:&#13;&#10;now plus 1.5 year&#13;&#10;is not valid whereas&#13;&#10;now + 2.5 days &#13;&#10;is valid&#13;&#10;&#13;&#10;An example of a query would be:&#13;&#10;select YEAR, MONTHNAME, DAYOFWEEK, DAYNAME from OTS_CALENDARDAY where PERIOD_START='now' and PERIOD_END='this week' and CULTURE_NAME='nl-NL'" T_RDMI_AUTOMATION_SERVER="N" T_RDMI_JAVA_COMPONENT="N" T_RDMI_STATEFUL_COMPONENT="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" T_RDMI_WEB_SERVICE_COMPONENT="N" T_RDMI_DOTNET_COMPONENT="Y" T_RDMI_COMPONENT_CONSTRUCTOR="Y"/>
</Components>
<Domains documentName="Domains">
<T_DOMAIN DOMAIN_NAME="OTS_CALENDAR_INT_1" SUPER_DOMAIN="" DATATYPE="NUMBER" TOTAL_LENGTH="1" LENGTH_AFTER_PERIOD="0" F_DATATYPE="INT" F_TOTAL_LENGTH="1" F_LENGTH_AFTER_PERIOD="0" DISPLAY_LENGTH="" UPPERCASE="N" FIXED_LENGTH="N" IS_SEQNO="N" DEF_VALUE="" RANGE_LOW="" RANGE_HIGH="" HELP_TEXT="" IOFORMAT="" DBFORMAT="" DESCR="" PERC_FULL="" SEQNO_COMPONENT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" REGEXP=""/>
<T_DOMAIN DOMAIN_NAME="OTS_CALENDAR_INT_2" SUPER_DOMAIN="" DATATYPE="NUMBER" TOTAL_LENGTH="2" LENGTH_AFTER_PERIOD="0" F_DATATYPE="INT" F_TOTAL_LENGTH="1" F_LENGTH_AFTER_PERIOD="0" DISPLAY_LENGTH="" UPPERCASE="N" FIXED_LENGTH="N" IS_SEQNO="N" DEF_VALUE="" RANGE_LOW="" RANGE_HIGH="" HELP_TEXT="" IOFORMAT="" DBFORMAT="" DESCR="" PERC_FULL="" SEQNO_COMPONENT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" REGEXP=""/>
<T_DOMAIN DOMAIN_NAME="OTS_CALENDAR_INT_4" SUPER_DOMAIN="" DATATYPE="NUMBER" TOTAL_LENGTH="4" LENGTH_AFTER_PERIOD="0" F_DATATYPE="INT" F_TOTAL_LENGTH="1" F_LENGTH_AFTER_PERIOD="0" DISPLAY_LENGTH="" UPPERCASE="N" FIXED_LENGTH="N" IS_SEQNO="N" DEF_VALUE="" RANGE_LOW="" RANGE_HIGH="" HELP_TEXT="" IOFORMAT="" DBFORMAT="" DESCR="" PERC_FULL="" SEQNO_COMPONENT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" REGEXP=""/>
<T_DOMAIN DOMAIN_NAME="OTS_CALENDAR_STRING" SUPER_DOMAIN="" DATATYPE="NVARCHAR2" TOTAL_LENGTH="80" LENGTH_AFTER_PERIOD="" F_DATATYPE="CHAR" F_TOTAL_LENGTH="1" F_LENGTH_AFTER_PERIOD="" DISPLAY_LENGTH="30" UPPERCASE="N" FIXED_LENGTH="N" IS_SEQNO="N" DEF_VALUE="" RANGE_LOW="" RANGE_HIGH="" HELP_TEXT="" IOFORMAT="" DBFORMAT="" DESCR="" PERC_FULL="50" SEQNO_COMPONENT="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" REGEXP=""/>
</Domains>
<DotNet_Components documentName="DotNet Components">
<T_RDMI_DOTNET_COMPONENT COMPONENT_NAME="OTS_CALENDAR_DAY" DESCRIPTION="This Calendar component is intended to be used in a Calendar table component.&#13;&#10;OTS_CALENDARDAY steps through the days in a certain period.&#13;&#10;The default period is specified in the constructor SQL, together with a default culture and default month and day name format.&#13;&#10;&#13;&#10;This component has to be considered as an example showing various programming techniques. For production purposes, the example can be extended or reduces to the actual requirements.&#13;&#10;This example shows:&#13;&#10;&#9;-using C# calendar arithmetic&#13;&#10;&#9;-a C# component using a query protocol to support a table component. i.e. usage of a table in USoft that can be queried to show calendar data&#13;&#10;&#9;-an example of using query conditions; they are passed as parameters in an xml format to the QueryExe method when &quot;Extended query conditions&quot; are used.&#13;&#10;&#9;-the use of  a regular expression&#13;&#10;&#9;-parsing an Enum from a string&#13;&#10;&#9;&#9;&#13;&#10;&#13;&#10;The component table OTS_CALENDARDAY can be queried to find all days in a certain period.&#13;&#10;In the USoft application, open the OTS_CALENDARDAY table and query all records to see the result.&#13;&#10;The default period is set in the constructor SQL. This period  can be overridden by specifying values for  the period start and end in the query (i.e. specify value(s) for PERIOD_START and/or PERIOD_END).&#13;&#10;Note that specifying PERIOD_START and PERIOD_END is a way of parameterizing the component and deviates from normal table behaviour.&#13;&#10;Operators &lt;, &lt;=, &gt;, &gt;=, % (LIKE) are not supported therefore on these fields.&#13;&#10;(For deployment purposes one could remove such fields from the component and only specify the period in the constructor SQL)&#13;&#10;The start and end period also support a basic date expression. Besides plain dates (as e.g. 2019 or 1-5-2020) one can specify expressions like: now&#13;&#10;&#13;&#10;&#13;&#10;The default culture (set by the constructor SQL) can be overridden by passing a culture name as e.g. en_US.&#13;&#10;The culture determines the language used to show month and day names&#13;&#10;This too this is a way of parameterizing the component with the same note above about operators applies.&#13;&#10;&#13;&#10;The year can be set (and must of course fall in the period to find any days at all). &#13;&#10;The year can be used with conditions &lt;, &lt;=, &gt;, &gt;= and the component will use these conditions to reduce the number of days fetched for efficiency.&#13;&#10;Query conditions on the other fields (month number, day in month, day of week, day of year, month name, day name) are resolved by the rules engine.&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following helper methods:&#13;&#10;select OTS_CALENDARDAY.ListFormats()&#9;&#9;=&gt; lists all DateTime input formats that can be used to specify the period (in the constructor SQL and/or as query condition)&#13;&#10;select OTS_CALENDARDAY.ListCultures()&#9;&#9;=&gt; lists all the culture names (with their display name)&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following utility methods:&#13;&#10;select OTS_CALENDARDAY.AddDays( datestring, howmanydays, format)&#9;&#13;&#10;&#9;=&gt; reads the datestring (according to the input formats). An empty input string is taken as the current datetime.&#13;&#10;&#9;=&gt; adds a number of days, e.g. 5  (which can also be a fraction, e.g. 1.5) &#13;&#10;&#9;=&gt; produces a date string as output in the specified format. An empty format string is taken as the USoft default format ( yyyy/MMddHHmmss )&#13;&#10;&#13;&#10;select OTS_CALENDARDAY.DaysBetween(datestring1, datestring2)&#13;&#10;&#9;=&gt;reads both datestrings &#13;&#10;&#9;=&gt;produces the number of days (can be a fraction) between the two dates&#13;&#10;&#13;&#10;Simple date expressions are supported for the start and end of period. (You could extend/change the basic grammar or use professional parsing techniques for more, or entirely leave out this example behaviour).&#13;&#10;Expression examples (the expressions are case insensitive. For details check the  implementation of the ParseDateExpr method):&#13;&#10;now&#13;&#10;yesterday&#13;&#10;tomorrow&#13;&#10;this  Monday&#13;&#10;next Monday&#13;&#10;following Monday&#13;&#10;next year&#13;&#10;last year&#13;&#10;yesterday + 2 weeks&#13;&#10;previous Monday + 1 week&#13;&#10;this day plus 1 year&#13;&#10;&#13;&#10;Note that only English day names and the English names year, month and day are supported.&#13;&#10;Note that the interpretation of &quot;this year&quot; would be January first for the start period but December 31 for the end period.&#13;&#10;In other words, to get all days in a year you can use in both period fields (start of period and end of period) the search condition: this year &#13;&#10;This month likewise refers to the begin or the end of the month and this week refers to begin or end of this week. &#13;&#10;Note that the following week can be addressed as:&#13;&#10;next week&#13;&#10;or&#13;&#10;this week + 1 week&#13;&#10;Also note that:&#13;&#10;yesterday + 1 &#13;&#10;adds one day (i.e. the default amount unit is days)&#13;&#10;yesterday + 1 week&#13;&#10;adds one week to yesterday&#13;&#10;this day&#13;&#10;is equivalent to&#13;&#10;now&#13;&#10;&#13;&#10;Finally,  note that fractions are not supported for year and month units. That is:&#13;&#10;now plus 1.5 year&#13;&#10;is not valid whereas&#13;&#10;now + 2.5 days &#13;&#10;is valid&#13;&#10;&#13;&#10;An example of a query would be:&#13;&#10;select YEAR, MONTHNAME, DAYOFWEEK, DAYNAME from OTS_CALENDARDAY where PERIOD_START='now' and PERIOD_END='this week' and CULTURE_NAME='nl-NL'" T_RDMI_AUTOMATION_SERVER="N" T_RDMI_JAVA_COMPONENT="N" T_RDMI_STATEFUL_COMPONENT="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" T_RDMI_WEB_SERVICE_COMPONENT="N" T_RDMI_DOTNET_COMPONENT="Y" T_RDMI_COMPONENT_CONSTRUCTOR="Y" ASSEMBLYREFS="System.Xml.dll;System.Xml.Linq.dll" PROGRAM_SOURCE="using System;&#13;&#10;using System.Globalization;&#13;&#10;using System.Xml;&#13;&#10;using System.Xml.Linq;&#13;&#10;using System.Xml.XPath; &#13;&#10;using System.Text.RegularExpressions;&#13;&#10;&#13;&#10;class OTS_CALENDAR_DAY&#13;&#10;{&#13;&#10;&#9;private DayOfWeek&#9;m_first_day_of_week;&#13;&#10;&#9;private DayOfWeek&#9;m_last_day_of_week;&#13;&#10;&#9;private string&#9;&#9;m_month_name_fmt;&#13;&#10;&#9;private string&#9;&#9;m_day_name_fmt;&#13;&#10;&#9;private string&#9;&#9;m_period_default_start_str;&#13;&#10;&#9;private string&#9;&#9;m_period_default_end_str;&#13;&#10;&#9;private string&#9;&#9;m_period_start_str;&#13;&#10;&#9;private string&#9;&#9;m_period_end_str;&#13;&#10;&#9;private DateTime&#9;m_period_start;&#13;&#10;&#9;private DateTime&#9;m_period_end;&#13;&#10;&#9;private DateTime&#9;m_dt_iterate;&#13;&#10;&#9;private double&#9;&#9;m_days_step = 1.0;&#13;&#10;&#9;private string&#9;&#9;m_cult_str;&#13;&#10;&#9;private string&#9;&#9;m_default_cult_str;&#13;&#10;&#9;private CultureInfo&#9;m_default_cult = CultureInfo.CurrentCulture;&#13;&#10;&#9;private CultureInfo&#9;m_cult = CultureInfo.CurrentCulture;&#13;&#10;&#9;private readonly string[] m_formats= {&#13;&#10;&#9;&#9;&quot;dd MMMM yyyy&quot;, &quot;dd MMM yyyy&quot;, &quot;d MMMM yyyy&quot;, &quot;d MMM yyyy&quot;, &quot;d M yyyy&quot;, &quot;d M yy&quot;,&#13;&#10;&#9;&#9;&quot;dd-MMMM-yyyy&quot;, &quot;dd-MM-yyyy&quot;, &quot;dd-MMM-yyyy&quot;, &quot;dd-MMM-yy&quot;, &#13;&#10;&#9;&#9;&quot;d-MMMM-yyyy&quot;, &quot;d-M-yyyy&quot;, &quot;d-MMM-yyyy&quot;, &quot;d-MMM-yy&quot;,&#13;&#10;&#9;&#9;&quot;dd MM yyyy HH:mm:ss&quot;, &quot;dd MMM yyyy HH:mm:ss&quot;, &quot;dd MMM yyyy H:mm:ss&quot;, &quot;dd MMMM yyyy HH:mm:ss&quot;, &quot;dd MMMM yyyy H:mm:ss&quot;,&#13;&#10;&#9;&#9;&quot;dd MM yyyy HH:mm:ssZ&quot;, &quot;dd MMM yyyy HH:mm:ssZ&quot;, &quot;dd MMM yyyy H:mm:ssZ&quot;, &quot;dd MMMM yyyy HH:mm:ssZ&quot;, &quot;dd MMMM yyyy H:mm:ssZ&quot;,&#13;&#10;&#9;&#9;&quot;dd-MM-yyyy HH:mm:ss&quot;, &quot;dd-MM-yyyy H:mm:ss&quot;, &quot;dd-MMM-yy HH:mm:ss&quot;, &quot;dd-MMM-yy H:mm:ss&quot;,&#13;&#10;&#9;&#9;&quot;dd-MM-yyyy HH:mm:ssZ&quot;, &quot;dd-MM-yyyy H:mm:ssZ&quot;, &quot;dd-MMM-yy HH:mm:ssZ&quot;, &quot;dd-MMM-yy H:mm:ssZ&quot;,&#13;&#10;&#9;&#9;&quot;d M yyyy HH:mm:ss&quot;, &quot;d M H:mm:ss&quot;, &quot;d MMM yyyy HH:mm:ss&quot;, &quot;d MMM yyyy H:mm:ss&quot;,&#13;&#10;&#9;&#9;&quot;d M yyyy HH:mm:ssZ&quot;, &quot;d M H:mm:ssZ&quot;, &quot;d MMM yyyy HH:mm:ssZ&quot;, &quot;d MMM yyyy H:mm:ssZ&quot;,&#13;&#10;&#9;&#9;&quot;d-MMMM-yyyy HH:mm:ss&quot;, &quot;d-MMMM-yyyy H:mm:ss&quot;, &quot;d-M-yyyy HH:mm:ss&quot;, &quot;d-M-yyyy H:mm:ss&quot;, &quot;d-MMM-yy HH:mm:ss&quot;, &quot;d-MMM-yy H:mm:ss&quot;,&#13;&#10;&#9;&#9;&quot;d-MMMM-yyyy HH:mm:ssZ&quot;, &quot;d-MMMM-yyyy H:mm:ssZ&quot;, &quot;d-M-yyyy HH:mm:ssZ&quot;, &quot;d-M-yyyy H:mm:ssZ&quot;, &quot;d-MMM-yy HH:mm:ssZ&quot;, &quot;d-MMM-yy H:mm:ssZ&quot;,&#13;&#10;&#9;&#9;&quot;d-MMMM-yyyy HH:mm&quot;, &quot;d-MMMM-yyyy H:mm&quot;, &quot;d-M-yyyy HH:mm&quot;, &quot;d-M-yyyy H:mm&quot;, &quot;d-MMM-yy HH:mm&quot;, &quot;d-MMM-yy H:mm&quot;,&#13;&#10;&#9;&#9;&quot;dd-MM-yyyy HH:mm&quot;, &quot;dd-MM-yyyy H:mm&quot;, &quot;dd-MMM-yy HH:mm&quot;, &quot;dd-MMM-yy H:mm&quot;,&#13;&#10;&#9;&#9;&quot;d-MMMM-yyyy HHmm&quot;, &quot;d-MMMM-yyyy Hmm&quot;, &quot;d-M-yyyy HHmm&quot;, &quot;d-M-yyyy Hmm&quot;, &quot;d-MMM-yy HHmm&quot;, &quot;d-MMM-yy Hmm&quot;,&#13;&#10;&#9;&#9;&quot;dd-MM-yyyy HHmm&quot;, &quot;dd-MM-yyyy Hmm&quot;, &quot;dd-MMM-yy HHmm&quot;, &quot;dd-MMM-yy Hmm&quot;,&#13;&#10;&#9;&#9;@&quot;yyyy\/MMddHHmmss&quot;, // con date format&#13;&#10;&#9;&#9;@&quot;yyyy\/MMdd&quot;, // con date short format without time&#13;&#10;&#9;&#9;&quot;M/d/yyyy h:mm:ss tt&quot;, &quot;M/d/yyyy h:mm tt&quot;, &#13;&#10;&#9;&#9;&quot;MM/dd/yyyy hh:mm:ss&quot;, &quot;M/d/yyyy h:mm:ss&quot;, &#13;&#10;&#9;&#9;&quot;M/d/yyyy hh:mm tt&quot;, &quot;M/d/yyyy hh tt&quot;, &#13;&#10;&#9;&#9;&quot;M/d/yyyy h:mm&quot;, &quot;M/d/yyyy h:mm&quot;, &#13;&#10;&#9;&#9;&quot;MM/dd/yyyy hh:mm&quot;, &quot;M/dd/yyyy hh:mm&quot;,&#13;&#10;&#9;&#9;&quot;MM/d/yyyy HH:mm:ss.ffffff&quot;,&#13;&#10;&#9;&#9;&quot;yyyy-MM-dd'T'HH:mm:ss.fffffff'Z'&quot;,&#13;&#10;&#9;&#9;&quot;yyyy-MM-dd'T'HH:mm:ss&quot;,&#13;&#10;&#9;&#9;&quot;M/d/yyyy&quot;,&#13;&#10;&#9;&#9;&quot;yyyy&quot;&#13;&#10;&#9;};&#13;&#10;&#9;public OTS_CALENDAR_DAY(string cult_str, string month_name_fmt, string day_name_fmt, string period_start, string period_end, double days_step)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;m_cult_str = m_default_cult_str = string.IsNullOrEmpty(cult_str) ? CultureInfo.CurrentCulture.Name : cult_str;&#13;&#10;&#9;&#9;m_month_name_fmt = month_name_fmt;&#13;&#10;&#9;&#9;m_day_name_fmt = day_name_fmt;&#13;&#10;&#9;&#9;m_period_start_str =  m_period_default_start_str = period_start;&#13;&#10;&#9;&#9;m_period_end_str = m_period_default_end_str = period_end;&#13;&#10;&#9;&#9;m_days_step = days_step == 0 ? 1 : days_step;&#13;&#10;&#9;&#9;m_default_cult = m_cult = new CultureInfo(m_cult_str);&#13;&#10;&#9;}&#13;&#10;&#9;private bool ParseDateTime(XElement el, ref DateTime dt, ref string used_date_str)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;if(el!=null &amp;&amp; el.Value!=null)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;string op = el.Attribute(&quot;name&quot;)==null ? null : el.Attribute(&quot;name&quot;).Value;&#13;&#10;&#9;&#9;&#9;if(!&quot;=&quot;.Equals(op))&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;throw new Exception(string.Format(&quot;Operator {0} can not be used for period start or end, only literal date values can be used&quot;, op));&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;string col_name = el.XPathSelectElement(&quot;Column&quot;).Attribute(&quot;name&quot;).Value;&#13;&#10;&#9;&#9;&#9;if(ParseDateExpr(el.Value, ref dt, col_name))&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;used_date_str = el.Value;&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;else&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;dt = ParseDateTime(el.Value, ref used_date_str);&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;return true;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;return false;&#13;&#10;&#9;}&#13;&#10;&#9;private DateTime ParseDateTime(string date_str)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;string ref_null = null;&#13;&#10;&#9;&#9;return ParseDateTime(date_str, ref ref_null);&#13;&#10;&#9;}&#13;&#10;&#9;private DateTime ParseDateTime(string date_str, ref string used_date_str)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;DateTime dt = DateTime.Now;&#13;&#10;&#9;&#9;if(!string.IsNullOrEmpty(date_str))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;if (DateTime.TryParseExact(date_str, m_formats, m_default_cult, DateTimeStyles.AllowWhiteSpaces, out dt))&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;if(used_date_str!=null) used_date_str = date_str;&#13;&#10;&#9;&#9;&#9;&#9;return dt;&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;throw new Exception(string.Format(&quot;Failed to parse {0}, possible formats are: {1}&quot;, date_str, ListFormats()));&#13;&#10;&#9;}&#13;&#10;&#9;private bool ParseYearCondition(XElement el, ref int start_year, ref int last_year)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;if(el == null)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;return false;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;string op = el.Attribute(&quot;name&quot;)==null ? null : el.Attribute(&quot;name&quot;).Value;&#13;&#10;&#9;&#9;string year_str = el.Element(&quot;Value&quot;)==null? null : el.Element(&quot;Value&quot;).Value;&#13;&#10;&#9;&#9;if(op==null || year_str==null)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;return false;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;switch(op)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;case &quot;=&quot;:&#13;&#10;&#9;&#9;&#9;&#9;start_year = int.Parse(year_str);&#13;&#10;&#9;&#9;&#9;&#9;last_year = start_year;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;&amp;gt;&quot;:&#13;&#10;&#9;&#9;&#9;&#9;start_year = int.Parse(year_str) + 1;&#9;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;&amp;gt;=&quot;:&#13;&#10;&#9;&#9;&#9;&#9;start_year = int.Parse(year_str);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;&amp;lt;&quot;:&#13;&#10;&#9;&#9;&#9;&#9;last_year = int.Parse(year_str) - 1;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;&amp;lt;=&quot;:&#13;&#10;&#9;&#9;&#9;&#9;last_year = int.Parse(year_str) ;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;default: return false;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;return true;&#13;&#10;&#9;}&#13;&#10;&#9;public int RowsetSize()&#13;&#10;&#9;{&#13;&#10;&#9;&#9;m_period_start = ParseDateTime(m_period_start_str);&#13;&#10;&#9;&#9;m_period_end = ParseDateTime(m_period_end_str);&#13;&#10;&#9;&#9;return (int)((m_period_end - m_period_start).TotalDays / m_days_step);&#13;&#10;&#9;}&#13;&#10;&#9;public int QueryExe(string query_conditions)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;m_period_start_str = m_period_default_start_str;&#13;&#10;&#9;&#9;m_period_end_str = m_period_default_end_str;&#13;&#10;&#9;&#9;m_period_start = ParseDateTime(m_period_start_str);&#13;&#10;&#9;&#9;m_period_end = ParseDateTime(m_period_end_str);&#13;&#10;&#9;&#9;m_cult_str = m_default_cult_str;&#13;&#10;&#9;&#9;m_cult = m_default_cult;&#13;&#10;&#9;&#9;bool has_query_conditions = false; &#13;&#10;&#9;&#9;XDocument qc = null;&#13;&#10;&#9;&#9;try&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;qc = XDocument.Parse(query_conditions); &#13;&#10;&#9;&#9;&#9;has_query_conditions = true;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;catch(Exception) {};&#13;&#10;&#9;&#9;if(has_query_conditions)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;ParseDateTime(qc.XPathSelectElement(&quot;/SqlNode//Operator[Column[@name='PERIOD_START']]&quot;), ref m_period_start, ref m_period_start_str);&#13;&#10;&#9;&#9;&#9;ParseDateTime(qc.XPathSelectElement(&quot;/SqlNode//Operator[Column[@name='PERIOD_END']]&quot;), ref m_period_end, ref m_period_end_str);&#13;&#10;&#9;&#9;&#9;int start_year = m_period_start.Year;&#13;&#10;&#9;&#9;&#9;int last_year = m_period_end.Year;&#13;&#10;&#9;&#9;&#9;if (ParseYearCondition(qc.XPathSelectElement(&quot;/SqlNode//Operator[Column[@name='YEAR']]&quot;), ref start_year, ref last_year))&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;if(m_period_start &lt; new DateTime(start_year, 01, 01))&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;m_period_start = new DateTime(start_year, 01, 01);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;if(m_period_end &gt; new DateTime(last_year, 12, 31))&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;m_period_end = new DateTime(start_year, 12, 31);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;XElement cult_el = qc.XPathSelectElement(&quot;/SqlNode//Operator[Column[@name='CULTURE_NAME']]&quot;);&#13;&#10;&#9;&#9;&#9;if(cult_el!=null &amp;&amp; cult_el.Value !=null)&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;string op = cult_el.Attribute(&quot;name&quot;)==null ? null : cult_el.Attribute(&quot;name&quot;).Value;&#13;&#10;&#9;&#9;&#9;&#9;if(!&quot;=&quot;.Equals(op))&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;throw new Exception(&quot;Operator &quot; + op + &quot; not supported to specify a culture.&quot;);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;m_cult_str = (string)cult_el.Value;&#13;&#10;&#9;&#9;&#9;}&#9;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;try&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;if(!m_default_cult_str.Equals(m_cult_str))&#13;&#10;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;m_cult = new CultureInfo(m_cult_str);&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;m_first_day_of_week = m_cult.DateTimeFormat.FirstDayOfWeek;&#13;&#10;&#9;&#9;&#9;m_last_day_of_week = m_cult.LCID == 1033 /*En-us*/ ? DayOfWeek.Saturday : DayOfWeek.Sunday;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;catch(Exception e)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;throw new Exception(string.Format(&quot;Culture name {0} not valid: {1}. Valid culture names: {2}&quot;, m_cult_str, e.Message, ListCultures()));&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;m_dt_iterate = m_days_step &gt; 0 ? m_period_start : m_period_end;&#13;&#10;&#9;&#9;return 1;&#13;&#10;&#9;}&#13;&#10;&#9;public int QueryFetch(out string period_start, out string period_end, out string cult_name, out int year, out int month_no, out int day_no, out int week_no, out int day_of_week, out int day_of_year, out string month_name, out string day_name)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;period_start = m_period_start_str;&#13;&#10;&#9;&#9;period_end = m_period_end_str;&#13;&#10;&#9;&#9;cult_name = m_cult_str;&#13;&#10;&#9;&#9;day_of_week = (int)m_dt_iterate.DayOfWeek;&#13;&#10;&#9;&#9;year = m_dt_iterate.Year;&#13;&#10;&#9;&#9;DateTime last_day_of_year = new DateTime(year, 12, 31);&#13;&#10;&#9;&#9;// ISO8601 week number&#13;&#10;&#9;&#9;week_no = m_cult.Calendar.GetWeekOfYear(m_dt_iterate, m_cult.DateTimeFormat.CalendarWeekRule, m_first_day_of_week);&#13;&#10;&#9;&#9;week_no = week_no == 53 &amp;&amp; last_day_of_year.DayOfWeek != m_last_day_of_week ? 1 : week_no;&#13;&#10;&#9;&#9;day_of_year = m_dt_iterate.DayOfYear;&#13;&#10;&#9;&#9;month_no = m_dt_iterate.Month;&#13;&#10;&#9;&#9;day_no = m_dt_iterate.Day;&#13;&#10;&#9;&#9;month_name = m_dt_iterate.ToString(m_month_name_fmt, m_cult);&#13;&#10;&#9;&#9;day_name = m_dt_iterate.ToString(m_day_name_fmt, m_cult);&#13;&#10;&#9;&#9;if(m_dt_iterate &gt; m_period_end || m_dt_iterate &lt; m_period_start)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;return 0;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;m_dt_iterate = m_dt_iterate.AddDays(m_days_step);&#13;&#10;&#9;&#9;return 1;&#13;&#10;&#9;}&#13;&#10;&#9;public string AddDays(string date_str, double num_days, string format)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;if(string.IsNullOrEmpty(format))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;format = @&quot;yyyy\/MMddHHmmss&quot;;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;DateTime dt = DateTime.Now;&#13;&#10;&#9;&#9;if(!string.IsNullOrEmpty(date_str))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;dt = ParseDateTime(date_str);&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;dt = dt.AddDays(num_days);&#13;&#10;&#9;&#9;return dt.ToString(format, m_default_cult);&#13;&#10;&#9;}&#13;&#10;&#9;public double DaysBetween(string date_str1, string date_str2)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;DateTime dt1 = DateTime.Now, dt2 = DateTime.Now;&#13;&#10;&#9;&#9;if(!string.IsNullOrEmpty(date_str1))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;dt1 = ParseDateTime(date_str1);&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;if(!string.IsNullOrEmpty(date_str2))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;dt2 = ParseDateTime(date_str2);&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;TimeSpan span = dt2.Subtract(dt1);&#13;&#10;&#9;&#9;return Math.Round(span.TotalDays, 3); // loss of precision for fractions&#13;&#10;&#9;}&#13;&#10;&#9;public string ListCultures()&#13;&#10;&#9;{&#13;&#10;&#9;&#9;System.Text.StringBuilder result = new System.Text.StringBuilder();&#13;&#10;&#9;&#9;CultureInfo[] cinfo = CultureInfo.GetCultures(CultureTypes.AllCultures &amp; ~CultureTypes.NeutralCultures);&#13;&#10;&#9;&#9;foreach (CultureInfo cul in cinfo)&#13;&#10;        {&#13;&#10;            result.Append(cul.Name + &quot;\t\t&quot; + cul.DisplayName + Environment.NewLine );&#13;&#10;        }&#13;&#10;&#9;&#9;return result.ToString();&#13;&#10;&#9;}&#13;&#10;&#9;public string ListFormats()&#13;&#10;&#9;{&#13;&#10;&#9;&#9;System.Text.StringBuilder result = new System.Text.StringBuilder();&#13;&#10;&#9;&#9;foreach (string fmt in m_formats)&#13;&#10;        {&#13;&#10;            result.Append(fmt + Environment.NewLine);&#13;&#10;        }&#13;&#10;&#9;&#9;return result.ToString();&#13;&#10;&#9;}&#13;&#10;&#9;private DateTime FirstDayOfWeek(DateTime dt)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;var diff = dt.DayOfWeek - m_first_day_of_week;&#13;&#10;        diff = (diff &lt; 0) ? diff + 7 : diff;&#13;&#10;        return dt.AddDays(-diff);&#13;&#10;&#9;}&#13;&#10;&#9;private readonly Regex DateExProp = &#13;&#10;&#9;&#9;new Regex(&#9;@&quot;^(now|next|following|last|previous|preceding|this|soy|start\s*of\s*year|year\*start|eoy|end\s*of\s*year|year\s*end|yesterday|tomorrow|sow|start\s*of\s*week|eow|end\s*of\s*week|som|start\s*of\s*month)?((?&lt;=next|following|last|previous|preceding|this)\s*[\w]*)?\s*(plus|\+|minus|\-)?((?&lt;=plus|\+|minus|\-)\s*[\w\.]*)?\s*(years|year|months|month|weeks|week|days|day)?\s*$&quot;,&#13;&#10;&#9;&#9;&#9;&#9;&#9;RegexOptions.IgnoreCase);&#13;&#10;&#13;&#10;&#9;private bool ParseDateExpr(string expr, ref DateTime dt, string elname)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;bool result = true;&#13;&#10;&#9;&#9;Match m = DateExProp.Match(expr);&#13;&#10;&#9;&#9;if(!m.Success || m.Groups.Count &lt; 6 || string.IsNullOrWhiteSpace(m.Groups[0].Value))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;return false;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;string op1 = m.Groups[1].Value.Trim();&#13;&#10;&#9;&#9;string op2 = m.Groups[2].Value.Trim();&#13;&#10;&#9;&#9;string op3 =  m.Groups[3].Value.Trim();&#13;&#10;&#9;&#9;string op4 =  m.Groups[4].Value.Trim();&#13;&#10;&#9;&#9;string op5 =  m.Groups[5].Value.Trim();&#13;&#10;&#9;&#9;switch(op1.ToLower().Replace(&quot; &quot;, string.Empty))&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;case &quot;now&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = DateTime.Now;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;soy&quot;: case &quot;startofyear&quot;: case &quot;yearstart&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = new DateTime(DateTime.Now.Year, 01, 01);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;eoy&quot;: case &quot;endofyear&quot;: case &quot;yearend&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = new DateTime(DateTime.Now.Year, 12, 31);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;yesterday&quot;: &#13;&#10;&#9;&#9;&#9;&#9;dt = DateTime.Now.AddDays(-1);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;tomorrow&quot;: &#13;&#10;&#9;&#9;&#9;&#9;dt = DateTime.Now.AddDays(1);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;sow&quot;: case &quot;startofweek&quot;: case &quot;start of week&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = FirstDayOfWeek(DateTime.Now);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;eow&quot;: case &quot;endofweek&quot;: case &quot;end of week&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = FirstDayOfWeek(DateTime.Now).AddDays(6);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;som&quot;: case &quot;startofmonth&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;eom&quot;: case &quot;endofmonth&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1).AddMonths(1).AddDays(-1);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;this&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;DayOfWeek dow;&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(Enum.TryParse(op2, true, out dow))&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;int day_still = ((int)dow - (int)DateTime.Now.DayOfWeek + 7) % 7;&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now.AddDays(day_still);&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;else&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = ThisDate(op2, DateTime.Now, elname);&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;next&quot;: case &quot;following&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;DayOfWeek dow;&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now;&#13;&#10;&#9;&#9;&#9;&#9;&#9;bool isday_name = Enum.TryParse(op2, true, out dow);&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(isday_name)&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;int days_till = ((int)dow - (int)dt.DayOfWeek + 7) % 7;&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = dt.AddDays(days_till);&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;op2 = &quot;week&quot;;&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(!AddUnit(ref dt, &quot;1&quot;, op2, 1))&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;throw new Exception(string.Format(&quot;Unit invalid in {0}&quot;, op2));&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(!isday_name) dt = ThisDate(op2, dt, elname);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;last&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;DayOfWeek dow;&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now;&#13;&#10;&#9;&#9;&#9;&#9;&#9;bool is_day_name = Enum.TryParse(op2, true, out dow);&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(is_day_name)&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;int days_till = ((int)dow - (int)dt.DayOfWeek - 7) % 7;&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = dt.AddDays(days_till);&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;op2 = &quot;week&quot;;&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(!AddUnit(ref dt, &quot;1&quot;, op2, -1))&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;throw new Exception(string.Format(&quot;Unit invalid in {0}&quot;, op2));&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;if (!is_day_name) dt = ThisDate(op2, dt, elname);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;previous&quot;: case &quot;preceding&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;DayOfWeek dow;&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now;&#13;&#10;&#9;&#9;&#9;&#9;&#9;bool is_day_name = Enum.TryParse(op2, true, out dow);&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(is_day_name)&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;int days_till = ((int)dow - (int)DateTime.Now.DayOfWeek - 7) % 7;&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now.AddDays(days_till);&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;else&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(!AddUnit(ref dt, &quot;1&quot;, op2, -1))&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;throw new Exception(string.Format(&quot;Unit invalid in {0}&quot;, op2));&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;dt = ThisDate(op2, dt, elname);&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;default:&#13;&#10;&#9;&#9;&#9;&#9;&#9;if(string.IsNullOrWhiteSpace(op3) &amp;&amp; string.IsNullOrWhiteSpace(op4))&#13;&#10;&#9;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;&#9;return false;&#13;&#10;&#9;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = DateTime.Now;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;switch(op3)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;case &quot;plus&quot;: case &quot;+&quot;:&#13;&#10;&#9;&#9;&#9;&#9;if(!AddUnit(ref dt, op4, op5, 1)) throw new Exception(string.Format(&quot;Unit invalid in {0}&quot;, expr));&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;min&quot;: case &quot;-&quot;:&#13;&#10;&#9;&#9;&#9;&#9;if(!AddUnit(ref dt, op4, op5, -1)) throw new Exception(string.Format(&quot;Unit invalid in {0}&quot;, expr));&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;return result;&#13;&#10;&#9;}&#13;&#10;&#9;private bool AddUnit(ref DateTime dt, string n, string unit, int sign)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;double amount = sign * double.Parse(n, System.Globalization.NumberStyles.Any, CultureInfo.InvariantCulture);&#13;&#10;&#9;&#9;switch(unit)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;case &quot;week&quot;: case &quot;weeks&quot;: &#13;&#10;&#9;&#9;&#9;&#9;dt = dt.AddDays(amount * 7);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;month&quot;: case &quot;months&quot;:&#13;&#10;&#9;&#9;&#9;&#9;if(n.Contains(&quot;.&quot;)) throw new Exception(string.Format(&quot;Fractions in {0} are not supported for month units&quot;, n));&#13;&#10;&#9;&#9;&#9;&#9;dt = dt.AddMonths( (int)amount);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;year&quot;: case &quot;years&quot;:&#13;&#10;&#9;&#9;&#9;&#9;if(n.Contains(&quot;.&quot;)) throw new Exception(string.Format(&quot;Fractions in {0} are not supported for year units&quot;, n));&#13;&#10;&#9;&#9;&#9;&#9;dt = dt.AddYears( (int)amount);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;&quot;: case &quot;days&quot;: case &quot;day&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = dt.AddDays(amount);&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;default: return false;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;return true;&#13;&#10;&#9;}&#13;&#10;&#9;private DateTime ThisDate(string expr,  DateTime refdate, string elname)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;DateTime dt = refdate;&#13;&#10;&#9;&#9;bool isstart = elname.IndexOf(&quot;start&quot;, StringComparison.OrdinalIgnoreCase) &gt;=0;&#13;&#10;&#9;&#9;switch(expr)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;case &quot;year&quot;: dt = isstart ? new DateTime(refdate.Year, 01, 01) : new DateTime(refdate.Year, 12, 31); &#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;month&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;DateTime som = new DateTime(refdate.Year, refdate.Month , 01);&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = isstart ? som : new DateTime(refdate.Year, refdate.Month, som.AddMonths(1).AddDays(-1).Day); &#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;week&quot;:&#13;&#10;&#9;&#9;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;&#9;&#9;int diff = (7 + (refdate.DayOfWeek - m_first_day_of_week)) % 7;&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = refdate.AddDays(-1 * diff).Date;&#13;&#10;&#9;&#9;&#9;&#9;&#9;dt = isstart ? dt : dt.AddDays(6);&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;&#9;case &quot;day&quot;:&#13;&#10;&#9;&#9;&#9;&#9;dt = refdate;&#13;&#10;&#9;&#9;&#9;break;&#13;&#10;&#9;&#9;}&#13;&#10;&#9;&#9;return dt;&#13;&#10;&#9;}&#13;&#10;}" DOTNET_ACTIVE="Y" LANGUAGE="C#" ORIGIN="" APP_DOMAIN="Default"/>
</DotNet_Components>
<Methods documentName="Methods">
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="ADDDAYS" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="AddDays" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="DAYSBETWEEN" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="DaysBetween" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="LISTCULTURES" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="ListCultures" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="LISTFORMATS" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="ListFormats" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="OTS_CALENDAR_DAY" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="QUERYEXE" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="QueryExe" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="QueryFetch" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_METHOD COMPONENT_NAME="OTS_CALENDAR_DAY" METHOD_NAME="ROWSETSIZE" METHOD_SEQNO="1" PHYSICAL_METHOD_NAME="RowsetSize" DESCRIPTION="" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
</Methods>
<Parameters documentName="Parameters">
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="0" METHOD_NAME="ADDDAYS" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_AddDays" KIND="RETURN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="0" METHOD_NAME="DAYSBETWEEN" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_DaysBetween" KIND="RETURN" PRIMITIVE_DATA_TYPE="DOUBLE" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="0" METHOD_NAME="LISTCULTURES" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_ListCultures" KIND="RETURN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="0" METHOD_NAME="LISTFORMATS" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_ListFormats" KIND="RETURN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="ADDDAYS" METHOD_SEQNO="1" PARAMETER_NAME="datestr" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="DAYSBETWEEN" METHOD_SEQNO="1" PARAMETER_NAME="datestr1" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="cultstr" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="QUERYEXE" METHOD_SEQNO="1" PARAMETER_NAME="CONDITIONS" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="PERIOD_START" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="1" METHOD_NAME="ROWSETSIZE" METHOD_SEQNO="1" PARAMETER_NAME="CONDITIONS" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="2" METHOD_NAME="ADDDAYS" METHOD_SEQNO="1" PARAMETER_NAME="ndays" KIND="IN" PRIMITIVE_DATA_TYPE="DOUBLE" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="2" METHOD_NAME="DAYSBETWEEN" METHOD_SEQNO="1" PARAMETER_NAME="datestr2" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="2" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="monthnamefmt" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="2" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="PERIOD_END" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="3" METHOD_NAME="ADDDAYS" METHOD_SEQNO="1" PARAMETER_NAME="format" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="3" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="daynamefmt" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="3" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="CULTURE_NAME" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="4" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="period_start" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="4" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="YEAR" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="5" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="period_end" KIND="IN" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="5" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="MONTH_NO" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="6" METHOD_NAME="OTS_CALENDAR_DAY" METHOD_SEQNO="1" PARAMETER_NAME="daysstep" KIND="IN" PRIMITIVE_DATA_TYPE="DOUBLE" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="6" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="DAY_IN_MONTH" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="7" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="WEEK_NO" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="8" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="DAY_OF_WEEK" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="9" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="DAY_OF_YEAR" KIND="OUT" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="10" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="MONTH_NAME" KIND="OUT" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="11" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="DAY_NAME" KIND="OUT" PRIMITIVE_DATA_TYPE="STRING" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="999" METHOD_NAME="QUERYEXE" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_QueryExe" KIND="RETURN" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="999" METHOD_NAME="QUERYFETCH" METHOD_SEQNO="1" PARAMETER_NAME="Return_From_QueryFetch" KIND="RETURN" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
<T_RDMI_PARAMETER COMPONENT_NAME="OTS_CALENDAR_DAY" PARAMETER_SEQNO="999" METHOD_NAME="ROWSETSIZE" METHOD_SEQNO="1" PARAMETER_NAME="return" KIND="RETURN" PRIMITIVE_DATA_TYPE="LONG" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y"/>
</Parameters>
<Query_Protocol_Associations documentName="Query Protocol Associations">
<T_RDMI_QUERY_PROTOCOL COMPONENT_NAME="OTS_CALENDAR_DAY" PROTOCOL_NAME="QUERY" DESCRIPTION="" T_RDMI_QUERY_PROTOCOL="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" T_RDMI_AGGREGATE_PROTOCOL="N" QP_EXE_METHOD_NAME="QUERYEXE" QP_EXE_COMPONENT_NAME="OTS_CALENDAR_DAY" QP_EXE_METHOD_SEQNO="1" QP_FETCH_COMPONENT_NAME="OTS_CALENDAR_DAY" QP_FETCH_METHOD_NAME="QUERYFETCH" QP_FETCH_METHOD_SEQNO="1"/>
</Query_Protocol_Associations>
<Stateful_Components documentName="Stateful Components">
<T_RDMI_STATEFUL_COMPONENT COMPONENT_NAME="OTS_CALENDAR_DAY" DESCRIPTION="This Calendar component is intended to be used in a Calendar table component.&#13;&#10;OTS_CALENDARDAY steps through the days in a certain period.&#13;&#10;The default period is specified in the constructor SQL, together with a default culture and default month and day name format.&#13;&#10;&#13;&#10;This component has to be considered as an example showing various programming techniques. For production purposes, the example can be extended or reduces to the actual requirements.&#13;&#10;This example shows:&#13;&#10;&#9;-using C# calendar arithmetic&#13;&#10;&#9;-a C# component using a query protocol to support a table component. i.e. usage of a table in USoft that can be queried to show calendar data&#13;&#10;&#9;-an example of using query conditions; they are passed as parameters in an xml format to the QueryExe method when &quot;Extended query conditions&quot; are used.&#13;&#10;&#9;-the use of  a regular expression&#13;&#10;&#9;-parsing an Enum from a string&#13;&#10;&#9;&#9;&#13;&#10;&#13;&#10;The component table OTS_CALENDARDAY can be queried to find all days in a certain period.&#13;&#10;In the USoft application, open the OTS_CALENDARDAY table and query all records to see the result.&#13;&#10;The default period is set in the constructor SQL. This period  can be overridden by specifying values for  the period start and end in the query (i.e. specify value(s) for PERIOD_START and/or PERIOD_END).&#13;&#10;Note that specifying PERIOD_START and PERIOD_END is a way of parameterizing the component and deviates from normal table behaviour.&#13;&#10;Operators &lt;, &lt;=, &gt;, &gt;=, % (LIKE) are not supported therefore on these fields.&#13;&#10;(For deployment purposes one could remove such fields from the component and only specify the period in the constructor SQL)&#13;&#10;The start and end period also support a basic date expression. Besides plain dates (as e.g. 2019 or 1-5-2020) one can specify expressions like: now&#13;&#10;&#13;&#10;&#13;&#10;The default culture (set by the constructor SQL) can be overridden by passing a culture name as e.g. en_US.&#13;&#10;The culture determines the language used to show month and day names&#13;&#10;This too this is a way of parameterizing the component with the same note above about operators applies.&#13;&#10;&#13;&#10;The year can be set (and must of course fall in the period to find any days at all). &#13;&#10;The year can be used with conditions &lt;, &lt;=, &gt;, &gt;= and the component will use these conditions to reduce the number of days fetched for efficiency.&#13;&#10;Query conditions on the other fields (month number, day in month, day of week, day of year, month name, day name) are resolved by the rules engine.&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following helper methods:&#13;&#10;select OTS_CALENDARDAY.ListFormats()&#9;&#9;=&gt; lists all DateTime input formats that can be used to specify the period (in the constructor SQL and/or as query condition)&#13;&#10;select OTS_CALENDARDAY.ListCultures()&#9;&#9;=&gt; lists all the culture names (with their display name)&#13;&#10;&#13;&#10;The OTS_CALENDARDAY also offers the following utility methods:&#13;&#10;select OTS_CALENDARDAY.AddDays( datestring, howmanydays, format)&#9;&#13;&#10;&#9;=&gt; reads the datestring (according to the input formats). An empty input string is taken as the current datetime.&#13;&#10;&#9;=&gt; adds a number of days, e.g. 5  (which can also be a fraction, e.g. 1.5) &#13;&#10;&#9;=&gt; produces a date string as output in the specified format. An empty format string is taken as the USoft default format ( yyyy/MMddHHmmss )&#13;&#10;&#13;&#10;select OTS_CALENDARDAY.DaysBetween(datestring1, datestring2)&#13;&#10;&#9;=&gt;reads both datestrings &#13;&#10;&#9;=&gt;produces the number of days (can be a fraction) between the two dates&#13;&#10;&#13;&#10;Simple date expressions are supported for the start and end of period. (You could extend/change the basic grammar or use professional parsing techniques for more, or entirely leave out this example behaviour).&#13;&#10;Expression examples (the expressions are case insensitive. For details check the  implementation of the ParseDateExpr method):&#13;&#10;now&#13;&#10;yesterday&#13;&#10;tomorrow&#13;&#10;this  Monday&#13;&#10;next Monday&#13;&#10;following Monday&#13;&#10;next year&#13;&#10;last year&#13;&#10;yesterday + 2 weeks&#13;&#10;previous Monday + 1 week&#13;&#10;this day plus 1 year&#13;&#10;&#13;&#10;Note that only English day names and the English names year, month and day are supported.&#13;&#10;Note that the interpretation of &quot;this year&quot; would be January first for the start period but December 31 for the end period.&#13;&#10;In other words, to get all days in a year you can use in both period fields (start of period and end of period) the search condition: this year &#13;&#10;This month likewise refers to the begin or the end of the month and this week refers to begin or end of this week. &#13;&#10;Note that the following week can be addressed as:&#13;&#10;next week&#13;&#10;or&#13;&#10;this week + 1 week&#13;&#10;Also note that:&#13;&#10;yesterday + 1 &#13;&#10;adds one day (i.e. the default amount unit is days)&#13;&#10;yesterday + 1 week&#13;&#10;adds one week to yesterday&#13;&#10;this day&#13;&#10;is equivalent to&#13;&#10;now&#13;&#10;&#13;&#10;Finally,  note that fractions are not supported for year and month units. That is:&#13;&#10;now plus 1.5 year&#13;&#10;is not valid whereas&#13;&#10;now + 2.5 days &#13;&#10;is valid&#13;&#10;&#13;&#10;An example of a query would be:&#13;&#10;select YEAR, MONTHNAME, DAYOFWEEK, DAYNAME from OTS_CALENDARDAY where PERIOD_START='now' and PERIOD_END='this week' and CULTURE_NAME='nl-NL'" T_RDMI_AUTOMATION_SERVER="N" T_RDMI_JAVA_COMPONENT="N" T_RDMI_STATEFUL_COMPONENT="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" T_RDMI_WEB_SERVICE_COMPONENT="N" T_RDMI_DOTNET_COMPONENT="Y" T_RDMI_COMPONENT_CONSTRUCTOR="Y" LIFETIME="SESSION" TRANSACTIONAL="N" SUPPORTS_COMMIT="N" SUPPORTS_ROLLBACK="N" SUPPORTS_PRECOMMIT="N" SUPPORTS_TABLECOMPONENT="Y" SUPPORTS_UPDATE="N" SUPPORTS_INSERT="N" SUPPORTS_DELETE="N" SUPPORTS_CONDITIONS="Y" SUPPORTS_ROWSETSIZEHINT="Y"/>
</Stateful_Components>
<Tables documentName="Tables">
<T_TABLE TABLE_NAME="OTS_CALENDAR_DAY" TABLE_SHORT="OTS_CALENDARDAY" OBJECT_NAME="Calendar day" OBJECT_NAME_PLURAL="Calendar days" KEYHIDDEN="N" CRETAB="N" UPDATED="Y" STATIC_TABLE="N" INIT_NR_OF_ROWS="1000" NEXT_NR_OF_ROWS="500" T_SUBT_SUPERTYPE="" T_SUBT_SEPARATE_TABLE="Y" DELETE_SUPER_ON_DELETE="N" T_LOGICAL_VIEW="N" T_COMPONENT_TABLE="Y" INTERFACE="N" MODULE="" INTERFACE_CORRECT="Y" INTERFACE_SOURCE="" UNDER_VC="N" DELIVERABLE="N"/>
</Tables>
</MultiImport>
